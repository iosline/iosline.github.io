<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/11/ViewPager-Fragment-懒加载/" itemprop="url">
                  ViewPager+Fragment 懒加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-11T16:44:38+08:00" content="2015-08-11">
              2015-08-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###一、在ViewPager上做文章（原理上可行，但实际上未起作用）<br>viewpager默认多加载一个page</p>
<p>重写viewPager,将v4包里的ViewPager代码复制粘贴到新定义的LazyViewPager  </p>
<p>只需该一个默认变量值 </p>
<pre><code>private static final int DEFAULT_OFFSCREEN_PAGES = 0;   //默认为1 改为0  即默认加载多加载0个
</code></pre><p>###二、在Fragment上做文章<br>做应用开发的时候，一个Activity里面可能会以viewpager（或其他容器）与多个Fragment来组合使用，而如果每个fragment都需要去加载数据，或从本地加载，或从网络加载，那么在这个activity刚创建的时候就变成需要初始化大量资源。这样的结果，我们当然不会满意。那么，能不能做到当切换到这个fragment的时候，它才去初始化呢？</p>
<p><b>答案就在Fragment里的setUserVisibleHint这个方法里</b></p>
<p>该方法用于告诉系统，这个Fragment的UI是否是可见的。所以我们只需要继承Fragment并重写该方法，即可实现在fragment可见时才进行数据加载操作，即Fragment的懒加载。</p>
<p>####效果图：<br><img src="http://7xl32g.com1.z0.glb.clouddn.com/2015011308525158.gif"></p>
<p>####代码如下：</p>
<pre><code>public abstract class BaseFragment extends Fragment {  
    protected boolean isVisible;  

    protected boolean isFirst=true;
    /** 
     * 在这里实现Fragment数据的缓加载. 
     * @param isVisibleToUser 
     */  
    @Override  
    public void setUserVisibleHint(boolean isVisibleToUser) {  
        super.setUserVisibleHint(isVisibleToUser);  
        if(getUserVisibleHint()) {  
            isVisible = true;  
            onVisible();  
        } else {  
            isVisible = false;  
            onInvisible();  
        }  
    }  

    protected void onVisible(){  
        if(isFirst){
            lazyLoad();  
            isFirst=false;
        }

    }  

    protected abstract void lazyLoad();  

    protected void onInvisible(){}  
}  
</code></pre><p>在LazyFragment，我增加了三个方法，一个是onVisiable，即fragment被设置为可见时调用，一个是onInvisible，即fragment被设置为不可见时调用。另外再写了一个lazyLoad的抽象方法，该方法在onVisible里面调用。你可能会想，为什么不在getUserVisibleHint里面就直接调用呢？</p>
<p>###使用<br>我这么写是为了代码的复用。因为在fragment中，我们还需要创建视图（onCreateView()方法），可能还需要在它不可见时就进行其他小量的初始化操作（比如初始化需要通过AIDL调用的远程服务）等。而setUserVisibleHint是在onCreateView之前调用的，那么在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常。而把lazyLoad抽离成一个方法，那么它的子类就可以这样做：</p>
<pre><code>public class CustomListFragment extends BaseFragment {

private static final String FRAGMENT_INDEX = fragment_index;
private final int FIRST_FRAGMENT = 0;
private final int SECOND_FRAGMENT = 1;
private final int THIRD_FRAGMENT = 2;

private TextView mFragmentView;

private int mCurIndex = -1;
/** 标志位，标志已经初始化完成 */
private boolean isPrepared;
/** 是否已被加载过一次，第二次就不再去请求数据了 */
private boolean mHasLoadedOnce;

/**
 * 创建新实例
 * 
 * @param index
 * @return
 */
public static CustomListFragment newInstance(int index) {
    Bundle bundle = new Bundle();
    bundle.putInt(FRAGMENT_INDEX, index);
    CustomListFragment fragment = new CustomListFragment();
    fragment.setArguments(bundle);
    return fragment;
}

@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    if(mFragmentView == null) {
        mFragmentView = (TextView) inflater.inflate(R.layout.fragment, container, false);
        //获得索引值
        Bundle bundle = getArguments();
        if (bundle != null) {
            mCurIndex = bundle.getInt(FRAGMENT_INDEX);
        }
        isPrepared = true;
        lazyLoad();
    }

    //因为共用一个Fragment视图，所以当前这个视图已被加载到Activity中，必须先清除后再加入Activity
    ViewGroup parent = (ViewGroup)mFragmentView.getParent();
    if(parent != null) {
        parent.removeView(mFragmentView);
    }
    return mFragmentView;
}

@Override
protected void lazyLoad() {
    if (!isPrepared || !isVisible || mHasLoadedOnce) {
        return;
    }

    new AsyncTask&lt;void, boolean=&quot;&quot;&gt;() {

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            //显示加载进度对话框
            UIHelper.showDialogForLoading(getActivity(), 正在加载..., true);
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            try {
                Thread.sleep(2000);
                //在这里添加调用接口获取数据的代码
                //doSomething()
            } catch (Exception e) {
                e.printStackTrace();
            }
            return true;
        }

        @Override
        protected void onPostExecute(Boolean isSuccess) {
            if (isSuccess) {
                // 加载成功
                setView();
                mHasLoadedOnce = true;
            } else {
                // 加载失败
            }
            //关闭对话框
            UIHelper.hideDialogForLoading();
        }
    }.execute();
}

private void setView() {
    // 根据索引加载不同视图
    switch (mCurIndex) {
    case FIRST_FRAGMENT:
        mFragmentView.setText(第一个);
        break;

    case SECOND_FRAGMENT:
        mFragmentView.setText(第二个);
        break;

    case THIRD_FRAGMENT:
        mFragmentView.setText(第三个);
        break;
    }
}
  }
</code></pre><p>在上面的类当中，我们增加了一个标志位isPrepared，用于标志是否初始化完成。然后在我们所需要的初始化操作完成之后调用，如上面的例子当中，在初始化view之后，设置 isPrepared为true，同时调用lazyLoad()方法。而在lazyLoad()当中，判断isPrepared和isVisible只要有一个不为true就不往下执行。也就是仅当初始化完成，并且可见的时候才继续加载，这样的避免了未初始化完成就使用而带来的问题。 </p>
<p>####注意：<br><b>这样会引发一个问题，就是fragment每次来回切换都会判断是否可见，可见就加lazyload(),就会造成加载数据，我们不想加载….</b></p>
<p>####解决办法：<br><b>在lazyFragemnt 或者在 继承lazyFragment的fragment 中添加一个 标记值 默认 mHasLoadedOnce; 加载前先判断;第一次加载之后将 mHasLoadedOnce=true;</b></p>
<p>####最后<br>到这里我们只是写好了Fragment，在FragmentActivity中还需要对ViewPager设置一下，让它每次只加载一个Fragment，ViewPager.setOffscreenPageLimit(int limit)，其中参数可以设为0或者1，参数小于1时，会默认用1来作为参数，未设置之前，ViewPager会默认加载两个Fragment。所以，我们只需要调用下它，设置下加载Fragment个数即可。</p>
<pre><code>public class MainActivity extends FragmentActivity implements OnClickListener{

    private RadioButton mFstBtn;
    private RadioButton mSndBtn;
    private RadioButton mThdBtn;

    private ViewPager mViewPager;
    private ListFragmentPagerAdapter mPagerAdapter;
    private List&lt;fragment&gt; mFragments = new ArrayList&lt;fragment&gt;();

    private final int FIRST_FRAGMENT = 0;
    private final int SECOND_FRAGMENT = 1;
    private final int THIRD_FRAGMENT = 2;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initButton();
        initViewPager();
    }


    /**
     * 初始化按钮
     */
    private void initButton() {
        mFstBtn = (RadioButton)findViewById(R.id.id_rb_fst);
        mFstBtn.setOnClickListener(this);
        mSndBtn = (RadioButton)findViewById(R.id.id_rb_snd);
        mSndBtn.setOnClickListener(this);
        mThdBtn = (RadioButton)findViewById(R.id.id_rb_thd);
        mThdBtn.setOnClickListener(this);
    }


    /**
     * 初始化ViewPager控件
     */
    private void initViewPager() {
        mViewPager = (ViewPager)findViewById(R.id.id_vp_viewpager);
        //关闭预加载，默认一次只加载一个Fragment
        mViewPager.setOffscreenPageLimit(1);
        //添加Fragment
        mFragments.add(CustomListFragment.newInstance(FIRST_FRAGMENT));
        mFragments.add(CustomListFragment.newInstance(SECOND_FRAGMENT));
        mFragments.add(CustomListFragment.newInstance(THIRD_FRAGMENT));
        //适配器
        mPagerAdapter = new ListFragmentPagerAdapter(getSupportFragmentManager(), mFragments);
        mViewPager.setAdapter(mPagerAdapter);
        mViewPager.setOnPageChangeListener(onPageChangeListener);
    }


    private OnPageChangeListener onPageChangeListener = new OnPageChangeListener() {

        @Override
        public void onPageSelected(int position) {
            //根据用户选中的按钮修改按钮样式
            switch (position) {
            case FIRST_FRAGMENT:
                mFstBtn.setChecked(true);
                mSndBtn.setChecked(false);
                mThdBtn.setChecked(false);
                break;

            case SECOND_FRAGMENT:
                mFstBtn.setChecked(false);
                mSndBtn.setChecked(true);
                mThdBtn.setChecked(false);
                break;

            case THIRD_FRAGMENT:
                mFstBtn.setChecked(false);
                mSndBtn.setChecked(false);
                mThdBtn.setChecked(true);
            break;
            }
        }

        @Override
        public void onPageScrolled(int arg0, float arg1, int arg2) {}

        @Override
        public void onPageScrollStateChanged(int arg0) {}
    };


    @Override
    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.id_rb_fst:
            mViewPager.setCurrentItem(FIRST_FRAGMENT);
            break;

        case R.id.id_rb_snd:
            mViewPager.setCurrentItem(SECOND_FRAGMENT);
            break;

        case R.id.id_rb_thd:
            mViewPager.setCurrentItem(THIRD_FRAGMENT);
            break;
        }
    }
}
</code></pre><p>####小需求：<br>在懒加载的基础上 有时还需要viewpager的缓存，也就是不需要每次都加载，viewpager默认只保持当前条目的前一个和后一个条目…</p>
<p>这是我们就需要设置缓存条目的数量</p>
<pre><code>mViewPager.setOffscreenPageLimit(limitNum);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/10/ScrollView滑动到顶部或底部的响应/" itemprop="url">
                  ScrollView滑动到顶部或底部的相应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-10T18:10:53+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###本文主要介绍实现ScrollView滑动到底部或顶部响应的两种方式<br>两种实现方式的主要不同点在于判断滑动位置的地方，第一种方式在onScrollChanged函数中判断, 第二种在OnTouchListener的onTouch中判断。其他如是否滚动到边缘的判断、响应事件接口OnBorderListener、对外暴露的接口都一样。</p>
<p>第一种方式代码可见: <a href="https://github.com/Trinea/android-common/blob/master/src/cn/trinea/android/common/view/BorderScrollView.java" target="_blank" rel="external">onScrollChanged BorderScrollView</a></p>
<p>第二种方式代码可见: <a href="https://code.google.com/p/trinea-code/source/browse/trunk/BorderScrollView/BorderScrollView.java" target="_blank" rel="external">OnTouchListener BorderScrollView</a></p>
<p>1、<b>判断是否已经滚动到顶部或底部，代码如下：</b></p>
<pre><code>private void doOnBorderListener() {
    if (contentView != null &amp;&amp; contentView.getMeasuredHeight() &lt;= getScrollY() + getHeight()) {
        if (onBorderListener != null) {
            onBorderListener.onBottom();
        }
    } else if (getScrollY() == 0) {
        if (onBorderListener != null) {
            onBorderListener.onTop();
        }
    }
}
</code></pre><p>滚动到顶部判断：</p>
<pre><code>getScrollY() == 0
</code></pre><p>滚动到底部判断</p>
<pre><code>View contentView = getChildAt(0);
contentView.getMeasuredHeight() &lt;= getScrollY() + getHeight();
</code></pre><p>其中getChildAt表示得到ScrollView的child View，因为ScrollView只允许一个child view，所以contentView.getMeasuredHeight()表示得到子View的高度, getScrollY()表示得到y轴的滚动距离，getHeight()为scrollView的高度。当getScrollY()达到最大时加上scrollView的高度就的就等于它内容的高度了啊~</p>
<p>2、<b>定义到达顶部和底部响应事件接口OnBorderListener，包含onTop和onBottom函数</b></p>
<pre><code>/**
 * OnBorderListener, Called when scroll to top or bottom
 * 
 * @author 
 */
public static interface OnBorderListener {

    /**
     * Called when scroll to bottom
     */
    public void onBottom();

    /**
     * Called when scroll to top
     */
    public void onTop();
}
</code></pre><p>这个接口允许用户自定义到达底部和顶部的响应事件</p>
<p>####第一种方式: 在onScrollChanged函数中判断，主要代码如下：</p>
<pre><code>@Override
protected void onScrollChanged(int x, int y, int oldx, int oldy) {
    super.onScrollChanged(x, y, oldx, oldy);
    doOnBorderListener();
}
</code></pre><p>在ScrollView的onScrollChanged函数中判断是否到达顶部和底部，并进行相应事件调用，onScrollChanged函数在ScrollView中内容开始滚动时出发被调用。</p>
<p>####第二种方式: 在OnTouchListener的onTouch中判断，主要代码如下：</p>
<pre><code>this.onBorderTouchListener = new OnTouchListener() {

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_UP:
                doOnBorderListener();
                break;
        }
        return false;
    }

};
</code></pre><p>表示在touch结束后，手指拿起时执行doOnBorderListener，进行判断和响应。</p>
<p>####两种方式的比较：</p>
<p><b>第一种方式精确度高，但doOnBorderListener可能执行多次</b>，因为ScrollView滑动中，onScrollChanged总是在不停被调用，需要用户自己做并发控制，也可以参考<a href="https://github.com/Trinea/android-common/blob/master/src/cn/trinea/android/common/view/DropDownListView.java#L541" target="_blank" rel="external">DropDownListView</a>的写法让用户在自定义Listener执行结束后手动调用onBottomComplete函数。</p>
<p><b>第二种方式不会造成doOnBorderListener多次执行，但却可能一次都没有调用。</b>比如你快速滑动，还未到达底部手指已经松开，由于惯性滚动到底部，可能并不会执行doOnBorderListener。因为onTouch的ACTION_UP事件在手指松开已经接收到这时候却还没有到达底部。<br>两种方式各有优劣，大家可酌情选择。我要求准确响应，所以选择了第一种，自己再做下控制确保不会多次执行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/10/关于瀑布流解决OOM问题/" itemprop="url">
                  关于瀑布流解决OOM问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-10T14:36:01+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一款全图片的壁纸的app应用，既然是全图片那么，必不可免的会出现oom异常，非常的头疼麻烦~~~,其他的瀑布流开源项目使用总是出现这样或那样的问题….说实话，下面这么长的代码我都不想看，又乱</p>
<p>###借鉴<br>  <a href="http://pan.baidu.com/s/1i3rjMDJ" target="_blank" rel="external">资源借鉴</a>      //百度网盘里面有我借鉴的资源，可以下载来看一下</p>
<p>###自定义ScrollView解决OOM</p>
<pre><code>    /**
 * 自定义的ScrollView，在其中动态地对图片进行添加。
 *
 * @author guolin
 */
public class MyScrollView2 extends ScrollView {

    /**
     * 每页要加载的图片数量
     */
    public static final int PAGE_SIZE = 20;

    /**
     * 记录当前已加载到第几页
     */
    private int page;

    /**
     * 每一列的宽度
     */
    private int columnWidth;

    /**
     * 当前第一列的高度
     */
    private int firstColumnHeight;

    /**
     * 当前第二列的高度
     */
    private int secondColumnHeight;


    /**
     * 是否已加载过一次layout，这里onLayout中的初始化只需加载一次
     */
    private boolean loadOnce;


    /**
     * 第一列的布局
     */
    private LinearLayout firstColumn;

    /**
     * 第二列的布局
     */
    private LinearLayout secondColumn;


    /**
     * MyScrollView下的直接子布局。
     */
    private static View scrollLayout;

    /**
     * MyScrollView布局的高度。
     */
    private static int scrollViewHeight;

    /**
     * 记录上垂直方距向的滚动离。
     */
    private static int lastScrollY = -1;

    /**
     * 记录所有界面上的图片，用以可以随时控制对图片的释放。
     */
    private List&lt;ImageView&gt; imageViewList = new ArrayList&lt;ImageView&gt;();

    /**
     * 在Handler中进行图片可见性检查的判断，以及加载更多图片的操作。
     */
    /*private Handler handler = new Handler() {

        public void handleMessage(android.os.Message msg) {
            MyScrollView2 myScrollView = (MyScrollView2) msg.obj;
            int scrollY = myScrollView.getScrollY();
            // 如果当前的滚动位置和上次相同，表示已停止滚动
            if (scrollY == lastScrollY) {
                // 当滚动的最底部，并且当前没有正在下载的任务时，开始加载下一页的图片
                if (scrollViewHeight + scrollY &gt;= scrollLayout.getHeight()) {
                    myScrollView.loadMoreImages();
                }
                myScrollView.checkVisibility();
            } else {
                lastScrollY = scrollY;
                Message message = new Message();
                message.obj = myScrollView;
                // 5毫秒后再次对滚动位置进行判断
                handler.sendMessageDelayed(message, 5);
            }
        };

    };*/

    /**
     * MyScrollView的构造函数。
     *
     * @param context
     * @param attrs
     */
    public MyScrollView2(Context context, AttributeSet attrs) {
        super(context, attrs);
       handler.sendEmptyMessageDelayed(11,500);
//        setOnTouchListener(this);
    }

    Handler handler=new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            checkVisibility();
            handler.sendEmptyMessageDelayed(11,500);
        }
    };

    @Override
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
        super.onScrollChanged(l, t, oldl, oldt);
        doOnBorderListener();
    }

    public boolean isZhixing;  //到底部是会一直夹在数据 加个标记 就只会加载一次
    private void doOnBorderListener() {
        if (scrollViewHeight + getScrollY() &gt;= scrollLayout.getHeight()) {
            if(!isZhixing){
                LLogUtils.d(&quot;============loadCount===&quot; + loadCount);
                isZhixing=true;
                initData(loadCount);
            }
        } else if (getScrollY() == 0) {

        }
    }

    private String mUrl;

    public void setUrl(String url) {
        mUrl = url;
        initData(loadCount);
    }

    List&lt;GroupPicture&gt; imageDatas = new ArrayList&lt;&gt;();

    private void initData(int loadCount) {
        int firstIndex = (loadCount - 1) * 20;
        int endIndex = 20;
        String selectUrl = mUrl + &quot;&amp;limit_a=&quot; + firstIndex + &quot;&amp;limit_b=&quot; + endIndex;
        LApplication.getHttpUtils().send(HttpRequest.HttpMethod.GET, selectUrl, new RequestCallBack&lt;String&gt;() {

            @Override
            public void onSuccess(ResponseInfo&lt;String&gt; response) {
                String result = response.result;
                LogUtils.d(&quot;result&quot; + result);
                Response&lt;GroupPicture&gt; data = GsonUtil.get(result, new TypeToken&lt;Response&lt;GroupPicture&gt;&gt;() {
                });
                if (data.getStatus() == Response.FAILED) {
//                    ToastUtil.show(data.getMsg());
                } else {
                    List&lt;GroupPicture&gt; dataList = data.getList();

                    if (dataList == null || dataList.size() == 0) {
                        ToastUtil.show(&quot;暂未更多资源，敬请期待...&quot;);
                        return;
                    }
                        imageDatas.addAll(dataList);

                    LLogUtils.d(&quot;imageDatas===============&quot;+imageDatas.size());
                        loadMoreImages();
//                    handler.sendMessageDelayed(handler.obtainMessage(0, MyScrollView2.this), 5);


                }

            }

            @Override
            public void onFailure(HttpException arg0, String arg1) {
            }

        });
    }

    /**
     * 进行一些关键性的初始化操作，获取MyScrollView的高度，以及得到第一列的宽度值。并在这里开始加载第一页的图片。
     */
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
        if (changed &amp;&amp; !loadOnce) {
            scrollViewHeight = getHeight();
            scrollLayout = getChildAt(0);
            firstColumn = (LinearLayout) findViewById(R.id.first_column);
            secondColumn = (LinearLayout) findViewById(R.id.second_column);
            columnWidth = firstColumn.getWidth();
            loadOnce = true;
        }
    }

    /**
     * 监听用户的触屏事件，如果用户手指离开屏幕则开始进行滚动检测。
     */
   /* @Override
    public boolean onTouch(View v, MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_UP) {
            Message message = new Message();
            message.obj = this;
            handler.sendMessageDelayed(message, 5);
        }
        return false;
    }*/

    int loadCount = 1;


    /**
     * 开始加载下一页的图片，每张图片都会开启一个异步线程去下载。
     */
    public void loadMoreImages() {
        int startIndex = page * PAGE_SIZE;
        int endIndex = page * PAGE_SIZE + PAGE_SIZE;
        if (startIndex &lt; imageDatas.size()) {
            if (loadCount &gt;= 2) {
                Toast.makeText(getContext(), &quot;正在加载...&quot;, Toast.LENGTH_SHORT).show();
            }
            loadCount++;
            if (endIndex &gt; imageDatas.size()) {
                endIndex = imageDatas.size();
            }
            for (int i = startIndex; i &lt; endIndex; i++) {
                ImageView imageView = new ImageView(getContext());

                final GroupPicture bean = imageDatas.get(i);
                LApplication.getBitmapUtils().configDefaultShowOriginal(true);
                LApplication.getBitmapUtils().display(imageView, bean.getPictureUrl(), new BitmapLoadCallBack&lt;ImageView&gt;() {
                    @Override
                    public void onLoadCompleted(ImageView imageView, String s, Bitmap bitmap, BitmapDisplayConfig bitmapDisplayConfig, BitmapLoadFrom bitmapLoadFrom) {
                        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
                                ScreenUtil.getWidth() / 2, ScreenUtil.getWidth() / 2);
                        params.setMargins(ScreenUtil.dp2px(1), 0, 0, ScreenUtil.dp2px(1));
                        imageView.setTag(R.string.id, true);
                        imageView.setLayoutParams(params);
                        imageView.setImageBitmap(bitmap);
                        imageView.setScaleType(ScaleType.CENTER_CROP);

                        imageView.setTag(R.string.image_url, bean);
                        imageViewList.add(imageView);
                        imageView.setOnClickListener(new OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                Intent intent = new Intent(getContext(), ImageShowActivity.class);
                                String groupId = bean.getGroupId();
                                intent.putExtra(&quot;groupId&quot;, groupId);
                                getContext().startActivity(intent);
                            }
                        });

                        findColumnToAdd(imageView, ScreenUtil.getWidth() / 2).addView(imageView);

                        isZhixing=false;
                    }

                    @Override
                    public void onLoadFailed(ImageView imageView, String s, Drawable drawable) {

                    }
                });
            }

            page++;
        }
        checkVisibility();
    }

    /**
     * 遍历imageViewList中的每张图片，对图片的可见性进行检查，如果图片已经离开屏幕可见范围，则将图片替换成一张空图。
     */
    public void checkVisibility() {
        for (int i = 0; i &lt; imageViewList.size(); i++) {
            ImageView imageView = imageViewList.get(i);
            boolean isSet = (boolean) imageView.getTag(R.string.id);
            int borderTop = (Integer) imageView.getTag(R.string.border_top);
            int borderBottom = (Integer) imageView
                    .getTag(R.string.border_bottom);
            //这个地方 getScrollY()-ScreenUtil.getWidth() 和getScrollY() + scrollViewHeight+ScreenUtil.getWidth() 多加个ScreenUtil.getWidth() 是为了上下提前显示一张图片
            if (borderBottom &gt; getScrollY()-ScreenUtil.getWidth()
                &amp;&amp; borderTop &lt; getScrollY() + scrollViewHeight+ScreenUtil.getWidth()) {//show
                final GroupPicture bean = (GroupPicture) imageView.getTag(R.string.image_url);
                imageView.setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent(getContext(), ImageShowActivity.class);
                        String groupId = bean.getGroupId();
                        intent.putExtra(&quot;groupId&quot;, groupId);
                        getContext().startActivity(intent);
                    }
                });
                 if(!isSet) {
                     LApplication.getBitmapUtils().display(imageView, bean.getPictureUrl());
                     imageView.setTag(R.string.id, true);
                 }

            } else {
                imageView.setImageResource(R.drawable.empty_photo);
                imageView.setOnClickListener(null);
                imageView.setTag(R.string.id, false);
            }
        }
    }

    public LinearLayout findColumnToAdd(ImageView imageView, int imageHeight) {
        if (firstColumnHeight &lt;= secondColumnHeight) {
            imageView.setTag(R.string.border_top, firstColumnHeight);
            firstColumnHeight += imageHeight;
            imageView.setTag(R.string.border_bottom, firstColumnHeight);
            return firstColumn;
        } else {
            imageView.setTag(R.string.border_top, secondColumnHeight);
            secondColumnHeight += imageHeight;
            imageView
                    .setTag(R.string.border_bottom, secondColumnHeight);
            return secondColumn;
        }
    }


}
</code></pre><p>此自定义ScrollView没有使用常规的实现解耦分离、这点没有做好~~</p>
<p>使用方法：或者将这个布局文件加到其他布局文件中 或者作为根布局文件<br>布局文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

    &lt;com.qiao.custom.MyScrollView2
        android:id=&quot;@+id/select_scroll&quot;
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:orientation=&quot;vertical&quot;&gt;

            //在顶部加了个自定义的viewPager 轮播图     看需求 不需要删除 不影响
             &lt;com.klo.zz.bizhi.widget.CustomeViewPager
                android:id=&quot;@+id/lunbo_pager&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;/&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginTop=&quot;1dp&quot;
                android:orientation=&quot;horizontal&quot;&gt;

                &lt;LinearLayout
                    android:id=&quot;@+id/first_column&quot;
                    android:layout_width=&quot;0dp&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_weight=&quot;1&quot;
                    android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt;

                &lt;LinearLayout
                    android:id=&quot;@+id/second_column&quot;
                    android:layout_width=&quot;0dp&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_weight=&quot;1&quot;
                    android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt;
            &lt;/LinearLayout&gt;
        &lt;/LinearLayout&gt;
    &lt;/com.qiao.custom.MyScroll2&gt;
</code></pre><p>在String.xml中添加</p>
<pre><code>&lt;string name=&quot;border_top&quot;&gt;Border Top&lt;/string&gt;
&lt;string name=&quot;border_bottom&quot;&gt;Border Bottom&lt;/string&gt;
&lt;string name=&quot;image_url&quot;&gt;Image Url&lt;/string&gt;
&lt;string name=&quot;bitmap&quot;&gt;bitmap&lt;/string&gt;
&lt;string name=&quot;id&quot;&gt;99&lt;/string&gt;
</code></pre><p>在类里面 findViewById()找到 myScrollView 然后 setUrl();</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/10/关于Android-Studio的Gradle的配置的一些知识/" itemprop="url">
                  关于Android Studio的Gradle文件配置的一些知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-10T14:17:05+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###一、采用签名不再是debug的签名<br>  直接在编辑环境中运行app默认是debug签名的，我们想更改签名不是debug（例如，微信sdk接入分享的使用要求apk文件不能是debug签名，否则不生效）。</p>
<p>  我们需要在项目的build.gradle中android{} 根目录中添加：</p>
<pre><code>android{                        //在他的目录下添加

     signingConfigs{
            debug{
                storeFile file(&quot;haha.keystore&quot;)            //签名文件的名字 这是在根目录下
                storePassword &quot;haha123456&quot;                 //密码
                keyAlias &quot;zzu&quot;                            //组织（这个是刚开始生成签名文件时填的）
                keyPassword &quot;haha123456&quot;                   //key密码
            }
        }
 }
</code></pre><p>同时还要经签名文件 haha.keystore放到项目app的根目录下</p>
<p>或者在项目的build.gradle中android{}根目录中添加：</p>
<pre><code>Properties properties = new Properties()
properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())

signingConfigs {
        haha {                                              //haha 这个名字是随意命名的
            storeFile file(&quot;../keystore/haha.keystore&quot;)     // 签名文件的路径   这是在根目录下新建了keystore文件夹
            storePassword properties.getProperty(&quot;Password&quot;)
            keyAlias properties.getProperty(&quot;keyAlias&quot;)
            keyPassword properties.getProperty(&quot;Password&quot;)
        }


 buildTypes {
        release {
            signingConfig signingConfigs.haha      //配置
            minifyEnabled false    //时候开启混淆
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;   //混淆文件
        }

        debug {
            signingConfig signingConfigs.haha
        }
    }
</code></pre><p>然后在local.properties 中添加 </p>
<pre><code>keyAlias=haha
Password=haha123
</code></pre><p>###二、直接生成以什么命名格式的apk文件</p>
<p>同样是在项目的build.gradle中android{}根目录中添加：</p>
<pre><code>applicationVariants.all {
       variant -&gt;
           variant.outputs.each {
               output -&gt;
                   def oldFile = output.outputFile
                   if (variant.buildType.name.equals(&apos;release&apos;)) {

                         //生成的就是  bizhi-版本号-版本名_singed.apk
                       def releaseApkName=&apos;bizhi-&apos;+defaultConfig.versionCode+&quot;-&quot;+defaultConfig.versionName+&quot;-signed.apk&quot;
                       output.outputFile=new File(oldFile.parent,releaseApkName)
                   }
           }
   }
</code></pre><p>###三、Gradle多渠道打包<br>以有多渠道打包为例，</p>
<p>在AndroidManifest.xml里面会有这么一段：</p>
<pre><code>&lt;meta-data
    android:name=&quot;UMENG_CHANNEL&quot;
    android:value=&quot;Channel_ID&quot; /&gt;
</code></pre><p>里面的Channel_ID就是渠道标示。我们的目标就是在编译的时候这个值能够自动变化。</p>
<p><li>第一步 在AndroidManifest.xml里配置PlaceHolder</li></p>
<pre><code>&lt;meta-data
    android:name=&quot;UMENG_CHANNEL&quot;
    android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt;
</code></pre><p><li>第二步 在build.gradle设置productFlavors</li></p>
<pre><code>android {  
    productFlavors {
        xiaomi {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;xiaomi&quot;]
        }
        _360 {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;_360&quot;]
        }
        baidu {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baidu&quot;]
        }
        wandoujia {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wandoujia&quot;]
        }
    }  
}
</code></pre><p>或者批量修改</p>
<p>全选复制放进笔记</p>
<pre><code>android {  
    productFlavors {
        xiaomi {}
        _360 {}
        baidu {}
        wandoujia {}
    }  

    productFlavors.all { 
        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] 
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/30/关于ViewPager的一些知识/" itemprop="url">
                  关于ViewPager的一些知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-30T15:22:39+08:00" content="2015-07-30">
              2015-07-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##需求一：<br> ViewPager滑动到第一张继续向右滑、滑倒最后一张继续向左滑，之后的逻辑操作（例：弹出提示、打开另一个Activity等）</p>
<p> 这两种方法都有缺陷：弹出提示建议 方法二，打开新的Activity建议方法一</p>
<p>方法一：</p>
<pre><code>private int currentPageScrollStatus;
private void showData() {
    imageAdapter = new ImageAdapter();
    imagePager.setAdapter(imageAdapter);

    imagePager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            if (position == 0) {
                //如果offsetPixels是0页面也被滑动了，代表在第一页还要往左划
                if (positionOffsetPixels == 0 &amp;&amp; currentPageScrollStatus == 1) {
                    ToastUtil.show(&quot;已经是第一张了&quot;);
                }
            } else if (position == imageAdapter.getCount()-1) {
                //已经在最后一页还想往右划
                if (positionOffsetPixels == 0 &amp;&amp; currentPageScrollStatus == 1) {
                    ToastUtil.show(&quot;已经是最后一张了&quot;);
                }
            }
        }

        @Override
        public void onPageSelected(int position) {
            //切换page设置当前position值
            setCurrentPos(position);
        }

        @Override
        public void onPageScrollStateChanged(int state) {

            currentPageScrollStatus=state;
        }


    });
}
</code></pre><p>方法二：</p>
<pre><code>int currItem;

private void showData() {
    imageAdapter = new ImageAdapter();
    imagePager.setAdapter(imageAdapter);

    imagePager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
        int lastState=-1;
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
           currItem=position;
        }

        @Override
        public void onPageSelected(int position) {

        }

        @Override
        public void onPageScrollStateChanged(int state) {
            if(currItem == imageAdapter.getCount()-1 &amp;&amp; state == 0 &amp;&amp; lastState == 1){
                ToastUtil.show(&quot;已经是最后一张了&quot;);
            }if(currItem == 0 &amp;&amp; state == 0 &amp;&amp; lastState == 1){
                ToastUtil.show(&quot;已经是第一张了&quot;);
            }
            lastState = state;
        }

    });
}
</code></pre><p>####方法二解决缺陷：声明一个lastState值</p>
<p>##需求二：<br> 点击ViewPager的Item跳转到不同的，做不同的逻辑操作等</p>
<p> 不是viewpager.setOnItemClickListener</p>
<p> 而是在PagerAdapter 的instantiateItem()方法中根据postion 做相应的逻辑操作</p>
<pre><code>public Object instantiateItem(ViewGroup container, final int position) {
        final int location = position % mViewList.size();      //这是为了做无限轮播
        View view = mViewList.get(location);
        container.addView(view);
        view.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               Intent intent=new Intent(mContext, ImageShowActivity.class);
                intent.putExtra(&quot;groupId&quot;,mIdList.get(location));
                mContext.startActivity(intent);
            }
        });
        return view;
    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/30/自定义矩形、圆形等边框及相关知识/" itemprop="url">
                  自定义矩形、圆形等边框及相关知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-30T12:31:27+08:00" content="2015-07-30">
              2015-07-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#自定义边框（矩形、圆形、一半圆一般矩形等）</p>
<p>##需求<br> 做一个一半矩形、一半圆形的边框，而且左边没有边框、其他上、右、下要有1像素的边框。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:left=&quot;-2dp&quot;&gt;                    //重点：使左边没有描边
        &lt;shape android:shape=&quot;rectangle&quot;&gt;         //矩形      

            &lt;corners
                android:topLeftRadius=&quot;0dp&quot;       //左上圆角半径 0
                android:topRightRadius=&quot;15dp&quot;     //右上圆角半径 15 
                android:bottomLeftRadius=&quot;0dp&quot;      左下圆角半径 0
                android:bottomRightRadius=&quot;15dp&quot; /&gt;   //右下圆角半径 15


            &lt;gradient                            //矩形边框内填充颜色（渐变色）
                android:startColor=&quot;#55000000&quot;
                android:endColor=&quot;#55000000&quot;
                android:angle=&quot;270&quot; /&gt;


            &lt;stroke                              //描边 这样四周有1dp 的边框
                android:width=&quot;1dp&quot;
                android:color=&quot;#55ffffff&quot; /&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/25/android将给定图片维持宽高比例缩放后，截取正中间的正方形部分/" itemprop="url">
                  android将给定图片维持宽高比例缩放后，截取正中间的正方形部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-25T10:51:17+08:00" content="2015-07-25">
              2015-07-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Android将给定图片维持宽高比缩放后，截取正中间的正方形部分</p>
<p>###一、本地图片</p>
<p>本地图片只需将图片转换为bitmap对象即可。</p>
<pre><code> /**
     * 将给定图片维持宽高比缩放后，截取正中间的正方形部分。
     * @param bitmap      原图
     * @param edgeLength  希望得到的正方形部分的边长
     * @return  缩放截取正中部分后的位图。
     */
public static Bitmap centerSquareScaleBitmap(Bitmap bitmap, int edgeLength)
{
 if(null == bitmap || edgeLength &lt;= 0)
 {
  return  null;
 }

 Bitmap result = bitmap;
 int widthOrg = bitmap.getWidth();
 int heightOrg = bitmap.getHeight();

 if(widthOrg &gt; edgeLength &amp;&amp; heightOrg &gt; edgeLength)
 {
  //压缩到一个最小长度是edgeLength的bitmap
  int longerEdge = (int)(edgeLength * Math.max(widthOrg, heightOrg) / Math.min(widthOrg, heightOrg));
  int scaledWidth = widthOrg &gt; heightOrg ? longerEdge : edgeLength;
  int scaledHeight = widthOrg &gt; heightOrg ? edgeLength : longerEdge;
  Bitmap scaledBitmap;

        try{
         scaledBitmap = Bitmap.createScaledBitmap(bitmap, scaledWidth, scaledHeight, true);
        } 
        catch(Exception e){
         return null;
        }

     //从图中截取正中间的正方形部分。
     int xTopLeft = (scaledWidth - edgeLength) / 2;
     int yTopLeft = (scaledHeight - edgeLength) / 2;

     try{
      result = Bitmap.createBitmap(scaledBitmap, xTopLeft, yTopLeft, edgeLength, edgeLength);
      scaledBitmap.recycle();
     }
     catch(Exception e){
      return null;
     }         
 }

 return result;
}
</code></pre><p>###二、网络图片</p>
<p>使用xUtils框架中的Bitmaputils的display方法可以有效地将网络上的图片成功的显示在ImageView布局上。</p>
<p>其中new BitmapCallBack接口中的onLoadCompleted方法，表示load成功，可以得到Bitmap对象，截取我们就是要对bitmap进行操作。</p>
<p>然后调用上述的截取方法</p>
<pre><code>LApplication.getBitmapUtils().display(imageView, selectPicture.getPictureUrl(), new BitmapLoadCallBack&lt;View&gt;() {
        @Override
        public void onLoadCompleted(ImageView imageView, String s, Bitmap bitmap, BitmapDisplayConfig bitmapDisplayConfig, BitmapLoadFrom bitmapLoadFrom) {
            Bitmap showBitmap = centerSquareScaleBitmap(bitmap, ScreenUtil.getWidth() / 2);  //截取新的bitmap
            imageView.setBitmap(showBitmap);     //设显示所占的宽高
        }

        @Override
        public void onLoadFailed(View view, String s, Drawable drawable) {

        }
    });
</code></pre><p>###做了那么多，其实有时候还不如这样做，看情况而定吧 这个不行在用上面的：</p>
<pre><code>imageView.setScaleType(ScaleType.CENTER_CROP);      //就这一句话
LApplication.getBitmapUtils().display(imageView, selectPicture.getPictureUrl(), new BitmapLoadCallBack&lt;View&gt;() {
           @Override
           public void onLoadCompleted(ImageView imageView, String s, Bitmap bitmap, BitmapDisplayConfig bitmapDisplayConfig, BitmapLoadFrom bitmapLoadFrom) {
               imageView.setBitmap(bitmap);     
           }

           @Override
           public void onLoadFailed(View view, String s, Drawable drawable) {

           }
       });
</code></pre><p>###关于ScaleType 的图片说明</p>
<p><img src="http://7xl32g.com1.z0.glb.clouddn.com/smallPicture.png">小图<br><img src="http://7xl32g.com1.z0.glb.clouddn.com/bigPicture.png">大图</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/23/开发Android壁纸-设置壁纸、设置锁屏心得/" itemprop="url">
                  开发Android壁纸:设置壁纸、设置锁屏心得
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T18:32:44+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#开发Android壁纸:设置壁纸、设置锁屏<br>直接获取网络上的图片，然后设置壁纸、锁屏可以，不过我这里是先将网络上的图片下载下来，存到sd卡上，然后设置sd卡上的图片为壁纸。</p>
<p>##源码下载：<br>     这个我还没添加到github上，添加之后更改本位置的内容</p>
<p>##设置壁纸<br>      public class Wallpaper {</p>
<pre><code>    private Activity mContext;

    public Wallpaper(ImageShowActivity imageShowActivity) {
        mContext = imageShowActivity;
    }

    public void setWallPaper(String url) {
        int index = url.lastIndexOf(&quot;/&quot;);
        String pirtureName = url.substring(index + 1);
        String path = AppConfig.DOWN_PATH;
        File file = new File(path);
        if (!file.exists() &amp;&amp; !file.isDirectory()) {
            file.mkdir();
        }
        final String target = path + &quot;/&quot; + pirtureName;
        File targetFile = new File(target);
        if (targetFile.exists()) {
            set(target);
        } else {
            LApplication.getHttpUtils().download(url, target, new RequestCallBack&lt;File&gt;() {

                @Override
                public void onLoading(long total, long current, boolean isUploading) {
                    super.onLoading(total, current, isUploading);

                }

                @Override
                public void onSuccess(ResponseInfo&lt;File&gt; arg0) {
                    set(target);   //设置壁纸
                }

                @Override
                public void onFailure(HttpException arg0, String arg1) {
                    ToastUtil.show(&quot;网络异常&quot;);

                }
            });
        }
    }
    /**
     * 设置壁纸
     * @param target 图片路径
     */
    public void set(String target) {
        Bitmap bitmap = BitmapFactory.decodeFile(target);
        try {
            WallpaperManager wallpaperManager = android.app.WallpaperManager.getInstance(mContext);
            wallpaperManager.setBitmap(bitmap);
            ToastUtil.show(&quot;设置成功&quot;);
        } catch (IOException e) {
            String msg = &quot;设置桌面背景发生异常:&quot; + e.getLocalizedMessage();
        }
    }
}
</code></pre><p>别忘记在ApplicationManifest.xml 中加上权限的设置。</p>
<pre><code>&lt;uses-permission android:name = &quot;android.permission.SET_WALLPAPER&quot;/&gt;
</code></pre><p>壁纸设置方法有三种：  <b>（尼玛，这三种设置壁纸的方法，都不管我们的死活，直接设置随着屏幕滚动，图片都模糊了）</b></p>
<p>第一 通过WallpaperManager方法中的 setBitmap（）</p>
<pre><code>WallpaperManager wallpaperManager = WallpaperManager.getInstance(this);
 Resources res = getResources();
 Bitmap bitmap=BitmapFactory.decodeResource(res,R.drawable.h); 
  try{
    wallpaperManager.setBitmap(bitmap);
   }catch (IOException e){
   e.printStackTrace();
   }
</code></pre><p>第二 使用WallpaperManager的setResource(int ResourceID)方法</p>
<pre><code>WallpaperManager wallpaperManager = WallpaperManager.getInstance(this);
    try {
        wallpaperManager.setResource(ResourceID);
        Toast.makeText(this, &quot;设置成功&quot;, Toast.LENGTH_SHORT).show();
    } catch (IOException e) {
        e.printStackTrace();
}
</code></pre><p>第三 通过ContextWrapper 类中提供的setWallpaper（）方法</p>
<pre><code>Resources localResources = getBaseContext().getResources();
InputStream localInputStream2 = localResources.openRawResource(ResourceID);
           try {
               setWallpaper(localInputStream2);
           } catch (IOException e) {
               e.printStackTrace();
           }
</code></pre><p>####注意：设置单屏壁纸，不随着屏幕滑动而滑动<br>     public void set(String target) {<br>            Bitmap bitmap = BitmapFactory.decodeFile(target);<br>            try {<br>                WallpaperManager wallpaperManager = android.app.WallpaperManager.getInstance(mContext);<br>                int desiredMinimumWidth = mContext.getWindowManager().getDefaultDisplay().getWidth();  //获取屏幕的宽<br>                int desiredMinimumHeight = mContext.getWindowManager().getDefaultDisplay().getHeight(); //获取屏幕的高<br>                 //bitmap这个参数再加工一次，缩放到desireMinimumWidth,desireMinmunHeight宽度和高度后再设置<br>                Bitmap sbitmap = sBitmap(bitmap,desiredMinimumWidth,desiredMinimumHeight);<br>                //很重要，有的手机少了这句话不行……..<br>                wallpaperManager.suggestDesiredDimensions(screenWidth, screenHeight);//设置期望壁纸的尺寸<br>                wallpaperManager.setBitmap(sbitmap);<br>                ToastUtil.show(“设置成功”);<br>            } catch (IOException e) {<br>                String msg = “设置桌面背景发生异常:” + e.getLocalizedMessage();<br>                ToastUtil.show(msg);<br>            }<br>        }<br>        public  Bitmap sBitmap(Bitmap b, int w, int h) {<br>            int width = b.getWidth();<br>            int height = b.getHeight();<br>            float scaleWidth = ((float) w) / width;<br>            float scaleHeight = ((float) h) / height;<br>            Matrix matrix = new Matrix();<br>            matrix.postScale(scaleWidth, scaleHeight);//缩放<br>            return Bitmap.createBitmap(b, 0, 0, width, height, matrix, true);<br>        }</p>
<p>##设置锁屏(此处的设置锁屏无法禁用home键，而且不好看，马上推出好看的….)</p>
<h1><a href="https://github.com/iosline/lockScreen" target="_blank" rel="external">好看的锁屏：源码下载</a></h1>

<p><b>设置锁屏壁纸的原理：</b></p>
<p>  1.监测开机广播，开启锁屏服务，开启锁屏的Activity</p>
<p>  2.设置锁屏壁纸其实就是，监测手机解锁屏幕，然后start一个Activity,该Activity设置壁纸，设置滑动按钮，滑倒指定位置，将当前Activity finish掉即可。</p>
<p>  3.需要注意 home键    Home键在3.1之后就不能屏蔽掉了 所以我们采用广播的方式：在当前Activity注册监听home键的广播,然后重新启动该Activity</p>
<p>####代码如下：</p>
<p>设置锁屏：</p>
<pre><code>public class LockManager {

    private Activity mContext;

    public LockManager(ImageShowActivity imageShowActivity) {
        mContext = imageShowActivity;
    }

    public void setLock(String url) {
        int index = url.lastIndexOf(&quot;/&quot;);
        String pirtureName = url.substring(index + 1);
        String path = AppConfig.DOWN_PATH;
        File file = new File(path);
        if (!file.exists() &amp;&amp; !file.isDirectory()) {
            file.mkdir();
        }
        final String target = path + &quot;/&quot; + pirtureName;
        File targetFile = new File(target);
        if (targetFile.exists()) {
            set(target);
        } else {
            LApplication.getHttpUtils().download(url, target, new RequestCallBack&lt;File&gt;() {

                @Override
                public void onLoading(long total, long current, boolean isUploading) {
                    super.onLoading(total, current, isUploading);

                }

                @Override
                public void onSuccess(ResponseInfo&lt;File&gt; arg0) {
                    set(target);
                }

                @Override
                public void onFailure(HttpException arg0, String arg1) {
                    ToastUtil.show(&quot;网络异常&quot;);

                }
            });
        }
    }

    private void set(String target) {
        Intent i = new Intent(mContext, LockScreenActivity.class);
        i.putExtra(&quot;targetPath&quot;, target);     //将图片路径传过去，设置新的壁纸
        CacheUtil.save(&quot;targetLock&quot;,target);  //将图片路径存起来，这样做是为了 开机自动从存储系统里获取图片路径
        mContext.startActivity(i);
    }
}
</code></pre><p>在AndroidManifest.xml清单文件中配置</p>
<pre><code>&lt;!-- ############ 锁屏界面、服务、监听器############ --&gt;
  &lt;activity android:name=&quot;.lock.LockScreenActivity&quot; /&gt;

  &lt;service
      android:name=&quot;.lock.LockScreenService&quot;
      android:process=&quot;system&quot; /&gt;

  &lt;receiver
      android:name=&quot;.lock.LockScreenReceiver&quot;
      android:process=&quot;:remote&quot;&gt;
      &lt;intent-filter android:priority=&quot;1000&quot;&gt;
          &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
          &lt;action android:name=&quot;android.intent.action.USER_PRESENT&quot; /&gt;

          &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;
      &lt;/intent-filter&gt;
  &lt;/receiver&gt;
</code></pre><p>监测开机的广播 广播接收者   (注意：开机启动，启动锁屏的service,然后service里面启动LockScreenActivity)</p>
<pre><code> /**
 * 开机广播，启动activity
 * @author jyk
 *
 */
public class LockScreenReceiver extends BroadcastReceiver {
    private final static String TAG = &quot;LockScreenReceiver&quot;;
    //private KeyguardManager keyguardManager = null;
    //private KeyguardManager.KeyguardLock keyguardLock = null;

    @Override
    public void onReceive(Context context, Intent intent) {
        if(intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)){
            Intent mIntent = new Intent(context, LockScreenService.class);
            mIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

            //keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
            //keyguardLock = keyguardManager.newKeyguardLock(&quot;&quot;);
            //keyguardLock.disableKeyguard(); 

            context.startActivity(mIntent);
        }
    }
}
</code></pre><p>锁屏的服务 同时注册屏幕锁住与解锁的广播</p>
<pre><code>public class LockScreenService extends Service {
    private final static String TAG = &quot;LockScreenService&quot;;
    private Intent lockIntent;
    private KeyguardManager keyguardManager = null;
    private KeyguardManager.KeyguardLock keyguardLock = null;

    @Override
    public IBinder onBind(Intent arg0) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        lockIntent = new Intent(LockScreenService.this, LockScreenActivity.class);
        lockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        //注册广播
        IntentFilter mScreenOffFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
        LockScreenService.this.registerReceiver(mScreenOffReceiver, mScreenOffFilter);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        keyguardLock.reenableKeyguard();
        LockScreenService.this.unregisterReceiver(mScreenOffReceiver);
        //重新启动activity
        startService(new Intent(LockScreenService.this, LockScreenService.class));
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return Service.START_STICKY;
    }

    /**
     * 屏幕变亮的广播，这里要隐藏系统的锁屏界面
     */
    private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.i(TAG, intent.getAction());
            if(intent.getAction().equals(Intent.ACTION_SCREEN_OFF)
                    || intent.getAction().equals(Intent.ACTION_SCREEN_ON)){

                keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
                keyguardLock = keyguardManager.newKeyguardLock(&quot;&quot;);
                keyguardLock.disableKeyguard(); //这里就是取消系统默认的锁屏

                startActivity(lockIntent); //注意这里跳转的意图
            }
        }
    };
}
</code></pre><p>###注意：取消系统默认的锁屏代码出现一次就够了  出现两次就会失效……</p>
<p>锁屏的LockScreenActivity</p>
<pre><code>    public class LockScreenActivity extends Activity implements Runnable {
    private final String TAG = &quot;LockScreenActivity&quot;;
    private SliderRelativeLayout sliderRelativeLayout;
    public static int MSG_LOCK_SUCESS = 1;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE); //不要title
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN); //全屏显示
        setContentView(R.layout.activity_lock_screen);
        LApplication.init(this);

        //注册广播
        registerReceiver(mHomeKeyEventReceiver, new IntentFilter(
                Intent.ACTION_CLOSE_SYSTEM_DIALOGS));

        String targetPath = getIntent().getStringExtra(&quot;targetPath&quot;);
        if(targetPath == null){
            targetPath= CacheUtil.getString(&quot;targetLock&quot;);
        }
        Drawable bg = Drawable.createFromPath(targetPath);
        RelativeLayout lockBg = (RelativeLayout) findViewById(R.id.lock_bg);
        lockBg.setBackgroundDrawable(bg);

        StringData();
        sliderRelativeLayout = (SliderRelativeLayout) findViewById(R.id.sliderLayout);
        sliderRelativeLayout.setMainHandler(handler);
        sliderRelativeLayout.getBackground().setAlpha(180); //设置背景的透明度

        startService(new Intent(LockScreenActivity.this, LockScreenService.class)); //这里要显示的调用服务
    }

    public void StringData() {
        final Calendar c = Calendar.getInstance();
        c.setTimeZone(TimeZone.getTimeZone(&quot;GMT+8:00&quot;));
        String mYear = String.valueOf(c.get(Calendar.YEAR)); // 获取当前年份
        String mMonth = String.valueOf(c.get(Calendar.MONTH) + 1);// 获取当前月份
        String mDay = String.valueOf(c.get(Calendar.DAY_OF_MONTH));// 获取当前月份的日期号码
        String mWay = String.valueOf(c.get(Calendar.DAY_OF_WEEK));
        if (&quot;1&quot;.equals(mWay)) {
            mWay = &quot;日&quot;;
        } else if (&quot;2&quot;.equals(mWay)) {
            mWay = &quot;一&quot;;
        } else if (&quot;3&quot;.equals(mWay)) {
            mWay = &quot;二&quot;;
        } else if (&quot;4&quot;.equals(mWay)) {
            mWay = &quot;三&quot;;
        } else if (&quot;5&quot;.equals(mWay)) {
            mWay = &quot;四&quot;;
        } else if (&quot;6&quot;.equals(mWay)) {
            mWay = &quot;五&quot;;
        } else if (&quot;7&quot;.equals(mWay)) {
            mWay = &quot;六&quot;;
        }

        ((TextView) findViewById(R.id.time_day)).setText(mMonth + &quot;月&quot; + mDay + &quot;日&quot;);
        ((TextView) findViewById(R.id.time_week)).setText(&quot;星期&quot; + mWay);

        new Thread(this).start();
    }

    private Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (MSG_LOCK_SUCESS == msg.what) {
                //Toast.makeText(getApplicationContext(), R.string.lockSuccess, 1).show();
//                virbate();
                finish();
            }
            if (msg.what == 100) {
                ((TextView) findViewById(R.id.time_hour)).setText((String) msg.obj);
            }
            if(msg.what == 99){
                Intent intent=new Intent(LockScreenActivity.this,LockScreenActivity.class);
                startActivity(intent);
                finish();
            }
        }
    };

    @Override
    public void run() {
        try {
            while (true) {
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm&quot;);
                String str = sdf.format(new Date());
                handler.sendMessage(handler.obtainMessage(100, str));
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * 震动
     */
    /*private void virbate(){
        Vibrator vibrator = (Vibrator) this.getSystemService(Context.VIBRATOR_SERVICE);
        vibrator.vibrate(200);
    }*/

    /**
     * 屏蔽掉Home键   自从3.1之后 就不能屏蔽了
     */
    /*@Override
    public void onAttachedToWindow() {
        this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
        super.onAttachedToWindow();
    }*/

    /**
     * 屏蔽掉返回键
     */
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }

    /**
     * 监听是否点击了home键将客户端推到后台
     */
    private BroadcastReceiver mHomeKeyEventReceiver = new BroadcastReceiver() {
        String SYSTEM_REASON = &quot;reason&quot;;
        String SYSTEM_HOME_KEY = &quot;homekey&quot;;
        String SYSTEM_HOME_KEY_LONG = &quot;recentapps&quot;;

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {
                String reason = intent.getStringExtra(SYSTEM_REASON);
                if (TextUtils.equals(reason, SYSTEM_HOME_KEY)) {
                    //表示按了home键,程序到了后台
                    Toast.makeText(getApplicationContext(), &quot;home&quot;,Toast.LENGTH_SHORT).show();
                    handler.sendEmptyMessageDelayed(99,3);
                }else if(TextUtils.equals(reason, SYSTEM_HOME_KEY_LONG)){
                    //表示长按home键,显示最近使用的程序列表
                }
            }
        }
    };


    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mHomeKeyEventReceiver);
    }
}
</code></pre><p>LockScreenActivity 锁屏Activity的布局文件</p>
<pre><code>&lt;RelativeLayout xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/lock_bg&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.LockScreenActivity&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;100dp&quot;
        android:orientation=&quot;vertical&quot;
        android:gravity=&quot;center_horizontal&quot;
        android:background=&quot;@drawable/shape_locktime_bg&quot;
        android:padding=&quot;20dp&quot; &gt;

        &lt;TextView
            android:id=&quot;@+id/time_hour&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;11:30&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;50sp&quot; /&gt;

        &lt;LinearLayout
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:orientation=&quot;horizontal&quot; &gt;

            &lt;TextView
                android:id=&quot;@+id/time_day&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;07月07日&quot;
                android:textColor=&quot;@android:color/white&quot;
                android:textSize=&quot;30sp&quot; /&gt;

            &lt;TextView
                android:id=&quot;@+id/time_week&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;星期日&quot;
                android:textColor=&quot;@android:color/white&quot;
                android:textSize=&quot;30sp&quot; /&gt;
        &lt;/LinearLayout&gt;
    &lt;/LinearLayout&gt;

    &lt;com.klo.zz.bizhi.lock.SliderRelativeLayout
        android:id=&quot;@+id/sliderLayout&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:layout_marginBottom=&quot;100dp&quot;
        android:background=&quot;@drawable/shape_locktime_bg&quot;
         &gt;

        &lt;RelativeLayout
            android:id=&quot;@+id/relativeLayout1&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_alignParentLeft=&quot;true&quot;
            android:layout_centerHorizontal=&quot;true&quot;
            android:layout_centerVertical=&quot;true&quot; &gt;

            &lt;ImageView
                android:id=&quot;@+id/leftRing&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:src=&quot;@mipmap/arrow_right&quot; /&gt;

            &lt;TextView
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_centerHorizontal=&quot;true&quot;
                android:layout_centerVertical=&quot;true&quot;
                android:textColor=&quot;#FF0000&quot; /&gt;
        &lt;/RelativeLayout&gt;

        &lt;RelativeLayout
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_alignParentRight=&quot;true&quot;
            android:layout_centerHorizontal=&quot;true&quot;
            android:layout_centerVertical=&quot;true&quot; &gt;

            &lt;ImageView
                android:id=&quot;@+id/rightRing&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:src=&quot;@mipmap/arrow_right&quot; /&gt;

            &lt;TextView
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_centerHorizontal=&quot;true&quot;
                android:layout_centerVertical=&quot;true&quot;
                android:textColor=&quot;#FF0000&quot; /&gt;
        &lt;/RelativeLayout&gt;

        &lt;RelativeLayout
            android:layout_width=&quot;222dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginLeft=&quot;50dp&quot; &gt;

            &lt;ImageView
                android:id=&quot;@+id/loveView&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;match_parent&quot;
                android:layout_alignParentLeft=&quot;true&quot;
                android:layout_alignParentTop=&quot;true&quot;
                android:src=&quot;@mipmap/open_lock&quot; /&gt;
        &lt;/RelativeLayout&gt;
    &lt;/com.klo.zz.bizhi.lock.SliderRelativeLayout&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>滑动解锁屏幕的自定义view</p>
<p>SliderRelativeLayout 这个是从从网上找的，就不列出代码了。</p>
<p>#总结：<br>   不想写…….</p>
<p>###源码敬请期待………</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/23/Android自定义下拉刷新、上拉加载更多及PullToRegresh框架的用法/" itemprop="url">
                  Android自定义下拉刷新、上拉加载更多及PullToRefresh框架的用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T18:31:10+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#PullToRefresh框架的用法</p>
<p>###一、首先Android Studio 如何集成PullToRefresh框架</p>
<pre><code>dependencies {

    compile &apos;com.loopeer.android.thirdparty.pulltorefresh:Android-PullToRefresh:2.1.1&apos;
}
</code></pre><p>在项目的build.gradle里面添加上述代码，sysc now 同步即可完成集成。</p>
<p>Eclipse的集成不讲，太简单了。</p>
<p>###二、使用<br>里面很好的封装了PullToRefreshScrollView、PullToRefreshListView、PullToRefreshGridView.</p>
<p>和listview、gridview、scrollview 的用法一致。</p>
<p>首先在布局文件中</p>
<pre><code> &lt;com.handmark.pulltorefresh.library.PullToRefreshScrollView
        android:id=&quot;@+id/select_scroll&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;
&lt;/com.handmark.pulltorefresh.library.PullToRefreshScrollView&gt;
</code></pre><p>在代码中 这一个接口 支持下拉刷新和上拉加载更多   <b>OnRefreshListener2</b></p>
<pre><code>selectScroll= (PullToRefreshScrollView) view.findViewById(R.id.select_scroll);
selectScroll.setMode(PullToRefreshBase.Mode.BOTH);      //支持下拉刷新和上拉加载更多，否则只支持下拉刷新
selectScroll.setOnRefreshListener(new PullToRefreshBase.OnRefreshListener2&lt;ScrollView&gt;() {
    int loadCount = 2;

    @Override
    public void onPullDownToRefresh(PullToRefreshBase&lt;ScrollView&gt; pullToRefreshBase) {
        String label = DateUtils.formatDateTime(
                getActivity(),
                System.currentTimeMillis(),
                DateUtils.FORMAT_SHOW_TIME
                        | DateUtils.FORMAT_SHOW_DATE
                        | DateUtils.FORMAT_ABBREV_ALL);
        // 显示最后更新的时间
        pullToRefreshBase.getLoadingLayoutProxy()
                .setLastUpdatedLabel(label);
        selectList.clear();
        initSelectData(1);
    }

    @Override
    public void onPullUpToRefresh(PullToRefreshBase&lt;ScrollView&gt; pullToRefreshBase) {
        initSelectData(loadCount);
        loadCount++;
    }
});
</code></pre><p>别忘了 在加载完数据添加一句：</p>
<pre><code>selectScroll.onRefreshComplete();    //表示刷新或加载完毕
</code></pre><p>还有一个接口只支持下拉刷新     <b>OnRefreshListener</b></p>
<pre><code>selectScroll.setOnRefreshListener(new PullToRefreshBase.OnRefreshListener&lt;ScrollView&gt;() {

            @Override
            public void onPullDownToRefresh(PullToRefreshBase&lt;ScrollView&gt; pullToRefreshBase) {
                String label = DateUtils.formatDateTime(
                        getActivity(),
                        System.currentTimeMillis(),
                        DateUtils.FORMAT_SHOW_TIME
                                | DateUtils.FORMAT_SHOW_DATE
                                | DateUtils.FORMAT_ABBREV_ALL);
                // 显示最后更新的时间
                pullToRefreshBase.getLoadingLayoutProxy()
                        .setLastUpdatedLabel(label);

            }

        });
</code></pre><p>###出现的问题：</p>
<p>#####1.使用开源框架pullToRefresh的时候 适用pullToRefreshScrollView中嵌套listview的时候，不管listview上面有什么，会出现listview在顶部的问题</p>
<p>场景：</p>
<p>遇见这样的场景，listview顶部有一个viewpager，还要下拉刷新和上拉加载更多，网上的listviewForScrollView 会一直测量，造成卡顿的现象，不建议使用scrollview 嵌套viewpager和listviewForScrollView。</p>
<p><b>解决办法：</b></p>
<pre><code>pulltorefreshlistview.getRefreshableView().addHeaderView(customviewpager);  
</code></pre><p></p>
<p>让listview上面的组件获得焦点</p>
<pre><code>lunboPager.requestFocus();
lunboPager.setFocusable(true);
lunboPager.setFocusableInTouchMode(true);
</code></pre><p>#####2.在使用PullToRefreshScrollView的时候，里面使用ListviewForScrollView、GridViewForScrollView,没上拉加载更多、下拉刷新的时候会一直的刷新数据，因为ListviewForScrollView、GridViewForScrollView里面重写了onMeasure()方法,会不断的测量位置，这样很不舒服。</p>
<p>解决办法：</p>
<pre><code>外界调用只需一句话：将这个自定义添加到布局文件中，调用就是 flowingGroupLayout.addPicture(集合);

public class FlowingGroupLayout extends LinearLayout {
    public FlowingGroupLayout(Context context) {
        super(context);
        init();

    }

    private LinearLayout oneLayout;
    private LinearLayout twoLayout;

    private void init() {
        View.inflate(getContext(), R.layout.flowing_pic, this);
        oneLayout = (LinearLayout) findViewById(R.id.ll_one);
        twoLayout = (LinearLayout) findViewById(R.id.ll_two);
    }

    public FlowingGroupLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public FlowingGroupLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }
    public void clear() {
//        this.removeAllViews();
        oneLayout.removeAllViews();
        twoLayout.removeAllViews();
    }
    public void addPicture(final List&lt;GroupPicture&gt; beans) {
        LLogUtils.v(beans.size() + &quot;&quot;);
        for (int i = 0; i &lt; beans.size(); i++) {
            GroupPicture picture = beans.get(i);
            final View view = LViewHelper.getView(R.layout.picture_item, getContext());
            final int finalI1 = i;
            LApplication.getBitmapUtils().display(view.findViewById(R.id.picture), picture.getPictureUrl(), new BitmapLoadCallBack&lt;View&gt;() {
                @Override
                public void onLoadCompleted(View container, String s, Bitmap bitmap, BitmapDisplayConfig bitmapDisplayConfig, BitmapLoadFrom bitmapLoadFrom) {        
                    //这里面是对图片的缩放、拉伸然后设置到布局上，不用管
                    int bitmapWidth=bitmap.getWidth();
                    int bitmapHeight=bitmap.getHeight();
                    int screenWidth=ScreenUtil.getWidth()/2;
                    if(bitmapHeight&lt;screenWidth || bitmapWidth &lt; screenWidth){
                        float scale;
                        float scaleHeight=(float)screenWidth/bitmapHeight;
                        float scaleWidth=(float)screenWidth/bitmapWidth;
                        if(scaleHeight &gt; scaleWidth){
                            scale=scaleHeight;
                        }else{
                            scale=scaleWidth;
                        }
                        int newBitWidth=(int)(bitmapWidth*scale);
                        int newBitmapHeight=(int)(bitmapHeight*scale);
                        Bitmap newBitmap = Bitmap.createScaledBitmap(bitmap, newBitWidth, newBitmapHeight, true);
                        LLImageUtils.setBitmap((ImageView)container,screenWidth,screenWidth,newBitmap);
                    }else{
                        Bitmap showBitmap = ScaleBitmap.centerSquareScaleBitmap(bitmap, ScreenUtil.getWidth() / 2);
                        LLImageUtils.setBitmap((ImageView)container,0,showBitmap.getHeight(),showBitmap);
                    }

                    LayoutParams lp = new LayoutParams(ScreenUtil.getWidth()/2,ScreenUtil.getWidth()/2);
                    lp.bottomMargin=ScreenUtil.dp2px(1);

                    if (finalI1 % 2 == 0) {
                        //偶数
                        oneLayout.addView(view, lp);
                    } else {
                        //单数
                        twoLayout.addView(view, lp);
                    }
                }

                @Override
                public void onLoadFailed(View view, String s, Drawable drawable) {

                }

            });
            final int finalI = i;
            view.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(getContext(), ImageShowActivity.class);
                    String groupId = beans.get(finalI).getGroupId();
                    intent.putExtra(&quot;groupId&quot;, groupId);
                    getContext().startActivity(intent);
                }
            });

        }
    }
}
</code></pre><p>###参考资料：<br>   Android自定义控件——ListView的下拉刷新与上拉加载</p>
<pre><code>http://www.tuicool.com/articles/3uAVRva
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/23/解决listview中每一项都有不同的布局/" itemprop="url">
                  解决listview中每一项都有不同的布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T18:29:27+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#基本的两种方法解决listview中每一项都有不同的布局</p>
<p>###方法一：（转载）<br>实现代码</p>
<p>Adapter的代码</p>
<p>其中:ViewHolder分别是三个不同的布局,也就是ListView中每一项的布局</p>
<p>TYPE_1…是三种类型.</p>
<p>在使用不同布局的时候,getItemViewType和getViewType不能少,一般是不用这两个函数的重载的</p>
<pre><code>class RunRankAdapter extends BaseAdapter {  
    ArrayList&lt;HashMap&lt;String, Object&gt;&gt; ls;  
    Context mContext;  
    LinearLayout linearLayout = null;  
    LayoutInflater inflater;  
    TextView tex;  
    final int VIEW_TYPE = 3;  
    final int TYPE_1 = 0;  
    final int TYPE_2 = 1;  
    final int TYPE_3 = 2;  

    public RunRankAdapter(Context context,  
            ArrayList&lt;HashMap&lt;String, Object&gt;&gt; list) {  
        ls = list;  
        mContext = context;  
    }  

    @Override  
    public int getCount() {  
        return ls.size();  
    }  

    @Override  
    public Object getItem(int position) {  
        return ls.get(position);  
    }  

    @Override  
    public long getItemId(int position) {  
        return 0;  
    }  

    // 每个convert view都会调用此方法，获得当前所需要的view样式  
    @Override  
    public int getItemViewType(int position) {  
        int p = position;  
        if (p == 0)  
            return TYPE_1;  
        else if (p == 1)  
            return TYPE_2;  
        else  
            return TYPE_3;  
    }  

    @Override  
    public int getViewTypeCount() {  
        return 3;  
    }  

    @Override  
    public View getView(int position, View convertView, ViewGroup parent) {  
        ViewHolder1 holder1 = null;  
        ViewHolder2 holder2 = null;  
        ViewHolder3 holder3 = null;  
        int type = getItemViewType(position);  
        if (convertView == null) {  
            inflater = LayoutInflater.from(mContext);  
            // 按当前所需的样式，确定new的布局  
            switch (type) {  
            case TYPE_1:  

                convertView = inflater.inflate(R.layout.item_runrank1,  
                        parent, false);  
                holder1 = new ViewHolder1();  
                holder1.rank1 = (TextView) convertView  
                        .findViewById(R.id.tv_list1_rank);  
                holder1.time1 = (TextView) convertView  
                        .findViewById(R.id.tv_list1_time);  
                convertView.setTag(holder1);  
                break;  
            case TYPE_2:  
                convertView = inflater.inflate(R.layout.item_runrank2,  
                        parent, false);  
                holder2 = new ViewHolder2();  
                holder2.rank2 = (TextView) convertView  
                        .findViewById(R.id.tv_list2_rank);  
                holder2.time2 = (TextView) convertView  
                        .findViewById(R.id.tv_list2_time);  
                convertView.setTag(holder2);  
                break;  
            case TYPE_3:  
                convertView = inflater.inflate(R.layout.item_runrank3,  
                        parent, false);  
                holder3 = new ViewHolder3();  
                holder3.rank3 = (TextView) convertView  
                        .findViewById(R.id.tv_list3_rank);  
                holder3.time3 = (TextView) convertView  
                        .findViewById(R.id.tv_list3_time);  
                convertView.setTag(holder3);  
                break;  
            default:  
                break;  
            }  

        } else {  
            switch (type) {  
            case TYPE_1:  
                holder1 = (ViewHolder1) convertView.getTag();  
                break;  
            case TYPE_2:  
                holder2 = (ViewHolder2) convertView.getTag();  
                break;  
            case TYPE_3:  
                holder3 = (ViewHolder3) convertView.getTag();  
                break;  
            }  
        }  
        // 设置资源  
        switch (type) {  
        case TYPE_1:  
            holder1.rank1.setText(&quot;&quot; + (position + 1));  
            holder1.time1.setText(ls.get(position).get(&quot;time&quot;).toString());  
            break;  
        case TYPE_2:  
            holder2.rank2.setText(&quot;&quot; + (position + 1));  
            holder2.time2.setText(ls.get(position).get(&quot;time&quot;).toString());  
            holder2.totaldistance2.setText(ls.get(position)  
            break;  
        case TYPE_3:  
            holder3.rank3.setText(&quot;&quot; + (position + 1));  
            holder3.time3.setText(ls.get(position).get(&quot;time&quot;).toString());  
            break;  
        }  

        return convertView;  
    }  

    public class ViewHolder1 {  
        TextView rank1;  
        TextView time1;  
    }  

    public class ViewHolder2 {  
        TextView rank2;  
        TextView time2;  
    }  

    public class ViewHolder3 {  
        TextView rank3;  
        TextView time3;  
    }  
}  
</code></pre><p>使用方式:</p>
<p>声明并定义自己的Adapter,在ListView中设置他的Adapter</p>
<pre><code>private RunRankAdapter runRankAdapter;    
ArrayList&lt;HashMap&lt;String, Object&gt;&gt; runRank;    
ListView lv_runRank;  
runRank = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();    
runRankAdapter = new RunRankAdapter(this, runRank);    
lv_runRank = (ListView) findViewById(R.id.lv_runRank);    
lv_runRank.setAdapter(runRankAdapter);  
</code></pre><p>###方法二：<br>在主布局文件中包含一个LinearLayout. 并且设置android:orientation=”vertical”</p>
<p>定义两种不同的布局文件，然后代码中,根据不同条件调用.addview向LinearLayout加载就可以了</p>
<p>#自己的理解：  （拿两个不同的item举例）<br>这两种方法不同的item少了还行，多了就行不通了</p>
<p>####方法一：<br>创建两个不同布局的item，然后在adapter中根据position位置的不同判断添加不同的item布局</p>
<p>####方法二：<br>创建一个布局文件，用LinearLayout设置android:orientation=”vertical”<br>定义两种不同的布局，在代码中根据position及条件设置Visiablity属性为visiable及gone即可。</p>
<p>###复杂的多个item不同的情况，后续实现添加,敬请期待……..</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
